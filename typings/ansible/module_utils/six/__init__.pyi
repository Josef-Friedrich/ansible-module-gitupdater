"""
This type stub file was generated by pyright.
"""

from __future__ import absolute_import

import functools
import io
import itertools
import operator
import struct
import sys
import types
from importlib.util import spec_from_loader

import StringIO

"""Utilities for writing code that runs on Python 2 and 3"""
_BUNDLED_METADATA = ...
__author__ = ...
__version__ = ...
PY2 = ...
PY3 = ...
PY34 = ...
if PY3:
    string_types = ...
    integer_types = ...
    class_types = ...
    text_type = ...
    binary_type = ...
    MAXSIZE = ...
else:
    string_types = ...
    integer_types = ...
    class_types = ...
    text_type = ...
    binary_type = ...
if PY34: ...
else:
    spec_from_loader = ...

class _LazyDescr:
    def __init__(self, name) -> None: ...
    def __get__(self, obj, tp): ...

class MovedModule(_LazyDescr):
    def __init__(self, name, old, new=...) -> None: ...
    def __getattr__(self, attr): ...

class _LazyModule(types.ModuleType):
    def __init__(self, name) -> None: ...
    def __dir__(self): ...

    _moved_attributes = ...

class MovedAttribute(_LazyDescr):
    def __init__(self, name, old_mod, new_mod, old_attr=..., new_attr=...) -> None: ...

class _SixMetaPathImporter:
    """
    A meta path importer to import six.moves and its submodules.

    This class implements a PEP302 finder and loader. It should be compatible
    with Python 2.5 and all existing versions of Python3
    """

    def __init__(self, six_module_name) -> None: ...
    def find_module(self, fullname, path=...): ...
    def find_spec(self, fullname, path, target=...): ...
    def load_module(self, fullname): ...
    def is_package(self, fullname):  # -> bool:
        """
        Return true, if the named module is a package.

        We need this method to get correct spec objects with
        Python 3.4 (see PEP451)
        """
        ...
    def get_code(self, fullname):  # -> None:
        """Return None

        Required, if is_package is implemented"""
        ...
    get_source = ...
    def create_module(self, spec): ...
    def exec_module(self, module): ...

_importer = ...

class _MovedItems(_LazyModule):
    """Lazy loading of moved objects"""

    __path__ = ...

_moved_attributes = ...
if sys.platform == "win32": ...
moves = ...

class Module_six_moves_urllib_parse(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_parse"""

    ...

_urllib_parse_moved_attributes = ...

class Module_six_moves_urllib_error(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_error"""

    ...

_urllib_error_moved_attributes = ...

class Module_six_moves_urllib_request(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_request"""

    ...

_urllib_request_moved_attributes = ...

class Module_six_moves_urllib_response(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_response"""

    ...

_urllib_response_moved_attributes = ...

class Module_six_moves_urllib_robotparser(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_robotparser"""

    ...

_urllib_robotparser_moved_attributes = ...

class Module_six_moves_urllib(types.ModuleType):
    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""

    __path__ = ...
    parse = ...
    error = ...
    request = ...
    response = ...
    robotparser = ...
    def __dir__(self): ...

def add_move(move):  # -> None:
    """Add an item to six.moves."""
    ...

def remove_move(name):  # -> None:
    """Remove item from six.moves."""
    ...

if PY3:
    _meth_func = ...
    _meth_self = ...
    _func_closure = ...
    _func_code = ...
    _func_defaults = ...
    _func_globals = ...
else:
    _meth_func = ...
    _meth_self = ...
    _func_closure = ...
    _func_code = ...
    _func_defaults = ...
    _func_globals = ...
next = ...
if PY3:
    def get_unbound_function(unbound): ...

    create_bound_method = ...
    def create_unbound_method(func, cls): ...

    Iterator = ...
else:
    def get_unbound_function(unbound): ...
    def create_bound_method(func, obj): ...
    def create_unbound_method(func, cls): ...

    class Iterator:
        def next(self): ...

    callable = ...
get_method_function = ...
get_method_self = ...
get_function_closure = ...
get_function_code = ...
get_function_defaults = ...
get_function_globals = ...
if PY3:
    def iterkeys(d, **kw): ...
    def itervalues(d, **kw): ...
    def iteritems(d, **kw): ...
    def iterlists(d, **kw): ...

    viewkeys = ...
    viewvalues = ...
    viewitems = ...
else:
    def iterkeys(d, **kw): ...
    def itervalues(d, **kw): ...
    def iteritems(d, **kw): ...
    def iterlists(d, **kw): ...

    viewkeys = ...
    viewvalues = ...
    viewitems = ...
if PY3:
    def b(s): ...
    def u(s): ...

    unichr = ...
    int2byte = ...
    byte2int = ...
    indexbytes = ...
    iterbytes = ...
    StringIO = ...
    BytesIO = ...
    _assertCountEqual = ...
else:
    def b(s): ...
    def u(s): ...

    unichr = ...
    int2byte = ...
    def byte2int(bs): ...
    def indexbytes(buf, i): ...

    iterbytes = ...
    StringIO = ...
    _assertCountEqual = ...
    _assertRaisesRegex = ...
    _assertRegex = ...
    _assertNotRegex = ...

def assertCountEqual(self, *args, **kwargs): ...
def assertRaisesRegex(self, *args, **kwargs): ...
def assertRegex(self, *args, **kwargs): ...
def assertNotRegex(self, *args, **kwargs): ...

if PY3:
    exec_ = ...
    def reraise(tp, value, tb=...): ...

else:
    def exec_(_code_, _globs_=..., _locs_=...):  # -> None:
        """Execute code in a namespace."""
        ...

if sys.version_info[:2] > (3,): ...
else:
    def raise_from(value, from_value): ...

print_ = ...
if print_ is None:
    def print_(*args, **kwargs):
        """The new-style print function for Python 2.4 and 2.5."""
        ...

if sys.version_info[:2] < (3, 3):
    _print = ...
    def print_(*args, **kwargs): ...

if sys.version_info[0:2] < (3, 4):
    def wraps(wrapped, assigned=..., updated=...): ...

else:
    wraps = ...

def with_metaclass(meta, *bases):  # -> metaclass:
    """Create a base class with a metaclass."""

    class metaclass(type): ...

def add_metaclass(metaclass):  # -> (cls: Unknown) -> Unknown:
    """Class decorator for creating a class with a metaclass."""
    ...

def ensure_binary(s, encoding=..., errors=...):  # -> bytes | str:
    """Coerce **s** to six.binary_type.

    For Python 2:
      - `unicode` -> encoded to `str`
      - `str` -> `str`

    For Python 3:
      - `str` -> encoded to `bytes`
      - `bytes` -> `bytes`
    """
    ...

def ensure_str(s, encoding=..., errors=...):  # -> str:
    """Coerce *s* to `str`.

    For Python 2:
      - `unicode` -> encoded to `str`
      - `str` -> `str`

    For Python 3:
      - `str` -> `str`
      - `bytes` -> decoded to `str`
    """
    ...

def ensure_text(s, encoding=..., errors=...):  # -> str:
    """Coerce *s* to six.text_type.

    For Python 2:
      - `unicode` -> `unicode`
      - `str` -> `unicode`

    For Python 3:
      - `str` -> `str`
      - `bytes` -> decoded to `str`
    """
    ...

def python_2_unicode_compatible(klass):
    """
    A class decorator that defines __unicode__ and __str__ methods under Python 2.
    Under Python 3 it does nothing.

    To support Python 2 and 3 with a single code base, define a __str__ method
    returning text and apply this decorator to the class.
    """
    ...

__path__ = ...
__package__ = ...
if globals().get("__spec__") is not None: ...
if sys.meta_path: ...
