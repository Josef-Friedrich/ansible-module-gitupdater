"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager

__metaclass__ = type
FILE_ATTRIBUTES = ...
MODE_OPERATOR_RE = ...
USERS_RE = ...
PERMS_RE = ...
_PERM_BITS = ...
_EXEC_PERM_BITS = ...
_DEFAULT_PERM = ...

def is_executable(path):  # -> int:
    """is_executable(path)

    is the given path executable?

    :arg path: The path of the file to check.

    Limitations:

    * Does not account for FSACLs.
    * Most times we really want to know "Can the current user execute this
      file".  This function does not tell us that, only if any execute bit is set.
    """
    ...

def format_attributes(attributes): ...
def get_flags_from_attributes(attributes): ...
def get_file_arg_spec(): ...

class LockTimeout(Exception): ...

class FileLock:
    """
    Currently FileLock is implemented via fcntl.flock on a lock file, however this
    behaviour may change in the future. Avoid mixing lock types fcntl.flock,
    fcntl.lockf and module_utils.common.file.FileLock as it will certainly cause
    unwanted and/or unexpected behaviour
    """

    def __init__(self) -> None: ...
    @contextmanager
    def lock_file(
        self, path, tmpdir, lock_timeout=...
    ):  # -> Generator[None, None, None]:
        """
        Context for lock acquisition
        """
        ...
    def set_lock(self, path, tmpdir, lock_timeout=...):  # -> Literal[True]:
        """
        Create a lock file based on path with flock to prevent other processes
        using given path.
        Please note that currently file locking only works when it's executed by
        the same user, I.E single user scenarios

        :kw path: Path (file) to lock
        :kw tmpdir: Path where to place the temporary .lock file
        :kw lock_timeout:
            Wait n seconds for lock acquisition, fail if timeout is reached.
            0 = Do not wait, fail if lock cannot be acquired immediately,
            Default is None, wait indefinitely until lock is released.
        :returns: True
        """
        ...
    def unlock(self):  # -> Literal[True]:
        """
        Make sure lock file is available for everyone and Unlock the file descriptor
        locked by set_lock

        :returns: True
        """
        ...
